<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Voice Translator</title>
    
    <!-- iOSホーム画面アプリとしての設定 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- アイコン設定 -->
    <link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icon-16.png">
    <link rel="mask-icon" href="maskable-icon.png" color="#1a73e8">
    
    <!-- Webマニフェスト -->
    <link rel="manifest" href="manifest.json">
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: #f5f5f7;
            color: #333;
            padding: 20px;
            touch-action: manipulation;
        }
        
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .app-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .app-title {
            font-size: 32px;
            font-weight: 700;
            color: #1a73e8;
            margin-bottom: 5px;
        }
        
        .app-subtitle {
            font-size: 14px;
            color: #666;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .control-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .button-group {
            display: flex;
            gap: 20px;
            justify-content: center;
            min-height: 60px; /* 最小の高さを確保してレイアウトが崩れないようにする */
        }
        
        .language-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 50px;
            background-color: #1a73e8;
            color: white;
            font-weight: 500;
            font-size: 16px;
            cursor: pointer;
            border: none;
            outline: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        
        .language-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .language-button.japanese {
            background-color: #e74c3c;
        }
        
        .language-button.english {
            background-color: #2ecc71;
        }
        
        .language-button.stop {
            background-color: #dc3545;
            display: none;
        }
        
        .language-button.stop.visible {
            display: flex;
        }
        
        .language-button:active:not(:disabled) {
            transform: scale(0.96);
        }
        
        .language-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .recording .stop-button {
            animation: pulse-button 1.5s infinite;
        }
        
        @keyframes pulse-button {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }
        
        .status {
            font-size: 18px;
            padding: 8px 16px;
            background-color: #e8f0fe;
            border-radius: 20px;
            color: #1a73e8;
            font-weight: 500;
            display: inline-block;
        }
        
        .status.recording {
            background-color: #ffebee;
            color: #dc3545;
        }
        
        .status.idle {
            background-color: #e8f0fe;
            color: #1a73e8;
        }
        
        .status.processing {
            background-color: #fff8e1;
            color: #ff9800;
        }
        
        .status.error {
            background-color: #ffebee;
            color: #dc3545;
        }
        
        .result-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
            flex: 1;
        }
        
        .result-box {
            background-color: white;
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            min-height: 120px;
            border-left: 4px solid #1a73e8;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex: 1;
            position: relative;
        }
        
        .result-title {
            font-size: 14px;
            font-weight: 500;
            color: #666;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-content {
            font-size: 20px;
            line-height: 1.5;
            white-space: pre-wrap;
            flex: 1;
        }
        
        .language-indicator {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 12px;
            background-color: #e8f0fe;
            color: #1a73e8;
        }
        
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(26, 115, 232, 0.3);
            border-radius: 50%;
            border-top-color: #1a73e8;
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .translating-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #fff8e1;
            color: #ff9800;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            display: none;
        }
        
        .translating-indicator.visible {
            display: inline-block;
        }
        
        .app-footer {
            text-align: center;
            margin-top: 20px;
            font-size: 12px;
            color: #666;
        }
        
        .settings-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: transparent;
            border: none;
            color: #1a73e8;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        
        .settings-button:hover {
            background-color: rgba(26, 115, 232, 0.1);
        }
        
        /* エラーメッセージスタイル */
        .error-message {
            color: #dc3545;
            font-style: italic;
            margin-top: 5px;
        }
        
        /* API設定モーダル */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: white;
            border-radius: 12px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(0);
            animation: modal-in 0.3s ease-out;
        }
        
        @keyframes modal-in {
            0% {
                opacity: 0;
                transform: translateY(30px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-title {
            font-size: 24px;
            font-weight: 600;
            color: #1a73e8;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        
        .modal-title svg {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: #333;
        }
        
        .form-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #DADCE0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.2s;
        }
        
        .form-input:focus {
            border-color: #1a73e8;
            outline: none;
        }
        
        .form-help {
            font-size: 13px;
            color: #666;
            margin-top: 5px;
        }
        
        .button-row {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .reset-keys {
            margin-top: 15px;
            font-size: 13px;
            color: #666;
            text-align: center;
            cursor: pointer;
            text-decoration: underline;
        }
        
        /* Media Queries for mobile responsiveness */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
            
            .app-title {
                font-size: 28px;
            }
            
            .result-content {
                font-size: 18px;
            }
            
            .modal-content {
                padding: 20px;
                width: 95%;
            }
            
            .button-group {
                flex-direction: column;
                gap: 12px;
                width: 100%;
                max-width: 280px;
            }
            
            .language-button {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="app-header">
            <div class="app-title">Real-time Voice Translator</div>
            <div class="app-subtitle">Translate speech in real-time between English and Japanese</div>
        </div>
        
        <div class="control-container">
            <div class="button-group">
                <button class="language-button japanese" id="startJapaneseBtn">
                    <div class="language-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" width="20" height="20">
                            <path d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM389.4 260.4c-1.094 65.88-56.06 120.9-121.9 121.9c-5.938 0-10.8-4.812-10.8-10.75c0-5.938 4.859-10.75 10.8-10.75c55.25-1 100.1-45.88 101.2-101.2c0-5.938 4.859-10.75 10.8-10.75S389.4 254.5 389.4 260.4zM317.9 131.9c2.812 5.188 .9062 11.69-4.281 14.5c-5.094 2.812-11.59 .9219-14.41-4.266c-17.09-31.09-49.47-50.39-85.06-50.39c-5.938 0-10.75-4.812-10.75-10.75S208.2 70.25 214.1 70.25C259.3 70.25 299.7 93.59 317.9 131.9z"/>
                        </svg>
                    </div>
                    <span>開始</span>
                </button>
                
                <button class="language-button english" id="startEnglishBtn">
                    <div class="language-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" width="20" height="20">
                            <path d="M332.2 337.9c-2.8-3.5-7.8-4-11.2-1.2l-19.9 16c-3.5 2.8-4 7.8-1.2 11.2 1.6 1.9 3.9 3 6.2 3 1.8 0 3.5-0.6 5-1.8l19.9-16C334.5 346.4 335 341.4 332.2 337.9z"/>
                            <path d="M315.8 275.2c-2.8-3.5-7.8-4-11.2-1.2l-120 96.4c-3.5 2.8-4 7.8-1.2 11.2 1.6 1.9 3.9 3 6.2 3 1.8 0 3.5-0.6 5-1.8l120-96.4C318.1 283.7 318.6 278.6 315.8 275.2z"/>
                            <path d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM192 336c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8V336zM192 272c0 4.4-3.6 8-8 8h-64c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h64c4.4 0 8 3.6 8 8V272zM288 368c0 4.4-3.6 8-8 8h-96c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h96c4.4 0 8 3.6 8 8V368zM384 336c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8V336zM384 272c0 4.4-3.6 8-8 8h-64c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h64c4.4 0 8 3.6 8 8V272zM416 208c0 4.4-3.6 8-8 8H296c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h112c4.4 0 8 3.6 8 8V208zM160 208c0 4.4-3.6 8-8 8h-32c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h32c4.4 0 8 3.6 8 8V208zM256 208c0 4.4-3.6 8-8 8h-56c-4.4 0-8-3.6-8-8v-16c0-4.4 3.6-8 8-8h56c4.4 0 8 3.6 8 8V208zM128 144c0-4.4 3.6-8 8-8h256c4.4 0 8 3.6 8 8v16c0 4.4-3.6 8-8 8H136c-4.4 0-8-3.6-8-8V144z"/>
                        </svg>
                    </div>
                    <span>Start</span>
                </button>
                
                <button class="language-button stop" id="stopBtn" disabled>
                    <div class="language-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" fill="currentColor" width="20" height="20">
                            <path d="M272 63.1l-32 0c-26.51 0-48 21.49-48 47.1v288c0 26.51 21.49 48 48 48L272 448c26.51 0 48-21.49 48-48v-288C320 85.49 298.5 63.1 272 63.1zM80 63.1l-32 0c-26.51 0-48 21.49-48 48v288C0 426.5 21.49 448 48 448l32 0c26.51 0 48-21.49 48-48v-288C128 85.49 106.5 63.1 80 63.1z"/>
                        </svg>
                    </div>
                    <span>Stop</span>
                </button>
            </div>
            
            <div class="status idle" id="status">Ready</div>
            <!-- エラー表示用の要素を追加 -->
            <div class="error-message" id="errorMessage"></div>
        </div>
        
        <div class="result-container">
            <div class="result-box">
                <div class="result-title">
                    <span>Original</span>
                    <span class="language-indicator" id="sourceLanguage"></span>
                </div>
                <div class="result-content" id="originalText"></div>
                <div class="translating-indicator" id="listeningIndicator">Listening...</div>
            </div>
            
            <div class="result-box">
                <div class="result-title">
                    <span>Translation</span>
                    <span class="language-indicator" id="targetLanguage"></span>
                </div>
                <div class="result-content" id="translatedText"></div>
                <div class="translating-indicator" id="translatingIndicator">Translating...</div>
            </div>
        </div>
        
        <button class="settings-button" id="settingsButton">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </button>
        
        <div class="app-footer">
            Real-time Voice Translator © 2023
            <div class="reset-keys" id="resetKeys">Reset API Keys</div>
        </div>
    </div>
    
    <!-- API設定モーダル -->
    <div class="modal" id="apiModal">
        <div class="modal-content">
            <div class="modal-title">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>
                </svg>
                API Key Setup
            </div>
            <p style="margin-bottom: 20px;">Please enter your API keys to use the translator. These will be stored locally on your device.</p>
            
            <div class="form-group">
                <label class="form-label" for="openaiKey">OpenAI API Key</label>
                <input type="text" id="openaiKey" class="form-input" placeholder="sk-...">
                <div class="form-help">Get your key from <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI Dashboard</a></div>
            </div>
            
            <div class="form-group">
                <label class="form-label" for="gladiaKey">Gladia API Key</label>
                <input type="text" id="gladiaKey" class="form-input" placeholder="...">
                <div class="form-help">Get your key from <a href="https://app.gladia.io/" target="_blank">Gladia Dashboard</a></div>
            </div>
            
            <div class="button-row">
                <button id="saveApiKeys">Save & Start</button>
            </div>
        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Default API Keys
        const DEFAULT_OPENAI_API_KEY = '';
        const DEFAULT_GLADIA_API_KEY = '';
        
        // API Key storage
        let OPENAI_API_KEY = '';
        let GLADIA_API_KEY = '';
        
        // DOM Elements
        const startJapaneseBtn = document.getElementById('startJapaneseBtn');
        const startEnglishBtn = document.getElementById('startEnglishBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const errorMessage = document.getElementById('errorMessage');
        const originalText = document.getElementById('originalText');
        const translatedText = document.getElementById('translatedText');
        const sourceLanguage = document.getElementById('sourceLanguage');
        const targetLanguage = document.getElementById('targetLanguage');
        const apiModal = document.getElementById('apiModal');
        const settingsButton = document.getElementById('settingsButton');
        const openaiKeyInput = document.getElementById('openaiKey');
        const gladiaKeyInput = document.getElementById('gladiaKey');
        const saveApiKeysBtn = document.getElementById('saveApiKeys');
        const resetKeysBtn = document.getElementById('resetKeys');
        const listeningIndicator = document.getElementById('listeningIndicator');
        const translatingIndicator = document.getElementById('translatingIndicator');
        
        // Speech recognition variables
        let recognition = null;
        let isRecording = false;
        let recognitionTimeout = null;
        let currentTranslationController = null;
        let lastProcessedText = '';
        let translationInProgress = false;
        let finalTranscript = '';
        let interimTranscript = '';
        let selectedLanguage = ''; // 'ja' for Japanese, 'en' for English
        let translationDebounceTimer = null;
        
        // Fallback to Gladia if Speech Recognition is not available
        let usingSpeechRecognition = true;
        let mediaRecorder = null;
        let audioChunks = [];
        
        // Load API keys
        function loadApiKeys() {
            const storedOpenaiKey = localStorage.getItem('translatorOpenaiKey');
            const storedGladiaKey = localStorage.getItem('translatorGladiaKey');
            
            OPENAI_API_KEY = storedOpenaiKey ? storedOpenaiKey.trim() : '';
            GLADIA_API_KEY = storedGladiaKey ? storedGladiaKey.trim() : '';
            
            if (!OPENAI_API_KEY || !GLADIA_API_KEY) {
                openaiKeyInput.value = DEFAULT_OPENAI_API_KEY;
                gladiaKeyInput.value = DEFAULT_GLADIA_API_KEY;
                apiModal.style.display = 'flex';
            } else {
                initializeApp();
            }
        }
        
        // Save API keys
        saveApiKeysBtn.addEventListener('click', () => {
            const openaiKey = openaiKeyInput.value.trim();
            const gladiaKey = gladiaKeyInput.value.trim();
            
            if (!openaiKey || !gladiaKey) {
                alert('Please enter both API keys.');
                return;
            }
            
            // APIキーを保存する前に不要なスペースを確実に削除
            localStorage.setItem('translatorOpenaiKey', openaiKey.trim());
            localStorage.setItem('translatorGladiaKey', gladiaKey.trim());
            
            OPENAI_API_KEY = openaiKey.trim();
            GLADIA_API_KEY = gladiaKey.trim();
            
            apiModal.style.display = 'none';
            initializeApp();
        });
        
        // Open settings modal
        settingsButton.addEventListener('click', () => {
            openaiKeyInput.value = OPENAI_API_KEY;
            gladiaKeyInput.value = GLADIA_API_KEY;
            apiModal.style.display = 'flex';
        });
        
        // Reset API keys
        resetKeysBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset your API keys?')) {
                localStorage.removeItem('translatorOpenaiKey');
                localStorage.removeItem('translatorGladiaKey');
                location.reload();
            }
        });
        
        // Close modal when clicking outside
        apiModal.addEventListener('click', (e) => {
            if (e.target === apiModal) {
                apiModal.style.display = 'none';
            }
        });
        
        // Initialize the app
        function initializeApp() {
            // Clear any previous error messages
            errorMessage.textContent = '';
            
            // Check if Web Speech API is supported
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                setupSpeechRecognition();
                usingSpeechRecognition = true;
            } else {
                // Fallback to using mediaRecorder and Gladia API
                usingSpeechRecognition = false;
                console.log('Web Speech API not supported, falling back to Gladia');
                
                // Check if Media API is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    status.textContent = 'Microphone access not supported in this browser.';
                    status.classList.remove('idle');
                    status.classList.add('error');
                    return;
                }
            }
            
            // Enable language buttons
            startJapaneseBtn.addEventListener('click', () => startRecording('ja'));
            startEnglishBtn.addEventListener('click', () => startRecording('en'));
            stopBtn.addEventListener('click', stopRecording);
            
            // Translation system prompt
            window.SYSTEM_PROMPT = `You are a professional simultaneous interpreter with expertise in Japanese and English. 
Your task is to transform and translate the audio input data into readable text according to these rules:

1. If the source text is Japanese, translate it to English.
2. If the source text is English, translate it to Japanese.
3. Remove fillers (um, uh, etc.) and redundant expressions.
4. When there is missing data, supplement based on context.
5. Preserve specialized terms, names, and cultural references accurately.
6. Make the output natural and conversational.
7. Respond ONLY with the translation, no explanations.`;
        }
        
        // Set up speech recognition
        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                usingSpeechRecognition = false;
                return;
            }
            
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;
            
            recognition.onstart = function() {
                console.log('Speech recognition started with language:', recognition.lang);
                listeningIndicator.classList.add('visible');
            };
            
            recognition.onend = function() {
                console.log('Speech recognition ended');
                
                // If we're supposed to be recording, restart recognition
                if (isRecording) {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error('Failed to restart recognition', e);
                    }
                } else {
                    listeningIndicator.classList.remove('visible');
                }
            };
            
            recognition.onresult = function(event) {
                clearTimeout(recognitionTimeout);
                
                // Reset interim transcript
                interimTranscript = '';
                
                // Process each result
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    
                    if (result.isFinal) {
                        finalTranscript += result[0].transcript + ' ';
                    } else {
                        interimTranscript += result[0].transcript;
                    }
                }
                
                // Display full transcript (final + interim)
                const fullTranscript = finalTranscript + interimTranscript;
                originalText.textContent = fullTranscript;
                
                // Set language indicators based on selected language
                if (selectedLanguage === 'ja') {
                    sourceLanguage.textContent = 'Japanese';
                    targetLanguage.textContent = 'English';
                } else {
                    sourceLanguage.textContent = 'English';
                    targetLanguage.textContent = 'Japanese';
                }
                
                // Only translate when we have significantly new content
                // or when there's a final result and it's been a while since the last translation
                if (finalTranscript.length > lastProcessedText.length + 5 || 
                    (finalTranscript.length > lastProcessedText.length && Date.now() - lastTranslationTime > 1000)) {
                    
                    // Debounce translation requests to avoid overwhelming the API
                    clearTimeout(translationDebounceTimer);
                    translationDebounceTimer = setTimeout(() => {
                        translateText(finalTranscript);
                        lastProcessedText = finalTranscript;
                    }, 300);
                }
                
                // Set a timeout to process interim results if they're stable for a while
                recognitionTimeout = setTimeout(() => {
                    if (interimTranscript && interimTranscript.length > 10) {
                        finalTranscript += interimTranscript + ' ';
                        interimTranscript = '';
                        
                        // Update UI
                        originalText.textContent = finalTranscript;
                        
                        // Translate this stable segment
                        translateText(finalTranscript);
                        lastProcessedText = finalTranscript;
                    }
                }, 1000);
            };
            
            recognition.onerror = function(event) {
                console.error('Recognition error', event.error);
                
                if (event.error === 'no-speech') {
                    // No speech detected - this is normal, just restart if we're still recording
                    if (isRecording) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.error('Failed to restart recognition after no-speech', e);
                        }
                    }
                } else if (event.error === 'audio-capture') {
                    status.textContent = 'No microphone detected';
                    status.classList.remove('idle', 'recording');
                    status.classList.add('error');
                    errorMessage.textContent = 'Could not detect a microphone. Please check your device settings.';
                    stopRecording();
                } else if (event.error === 'not-allowed') {
                    status.textContent = 'Microphone permission denied';
                    status.classList.remove('idle', 'recording');
                    status.classList.add('error');
                    errorMessage.textContent = 'Microphone access was denied. Please allow microphone access in your browser settings.';
                    stopRecording();
                }
            };
        }
        
        // Toggle button visibility for recording state
        function updateButtonVisibility(isRecordingState) {
            if (isRecordingState) {
                // Hide start buttons, show stop button
                startJapaneseBtn.style.display = 'none';
                startEnglishBtn.style.display = 'none';
                stopBtn.style.display = 'flex';
                stopBtn.disabled = false;
            } else {
                // Show start buttons, hide stop button
                startJapaneseBtn.style.display = 'flex';
                startEnglishBtn.style.display = 'flex';
                startJapaneseBtn.disabled = false;
                startEnglishBtn.disabled = false;
                stopBtn.style.display = 'none';
                stopBtn.disabled = true;
            }
        }
        
        // Start recording with specified language
        async function startRecording(language) {
            // Clear any previous error messages
            errorMessage.textContent = '';
            
            // Set the selected language
            selectedLanguage = language;
            
            // Reset UI
            finalTranscript = '';
            interimTranscript = '';
            lastProcessedText = '';
            originalText.textContent = '';
            translatedText.textContent = '';
            
            // Update language indicators
            if (language === 'ja') {
                sourceLanguage.textContent = 'Japanese';
                targetLanguage.textContent = 'English';
            } else {
                sourceLanguage.textContent = 'English';
                targetLanguage.textContent = 'Japanese';
            }
            
            // Update UI
            isRecording = true;
            document.body.classList.add('recording');
            status.textContent = 'Recording';
            status.classList.remove('idle', 'error');
            status.classList.add('recording');
            
            // Update button visibility - hide start buttons, show stop button
            updateButtonVisibility(true);
            
            if (usingSpeechRecognition) {
                // Using Web Speech API with explicitly set language
                try {
                    // Set the language for recognition
                    recognition.lang = language === 'ja' ? 'ja-JP' : 'en-US';
                    recognition.start();
                } catch (e) {
                    console.error('Error starting recognition', e);
                    errorMessage.textContent = 'Failed to start speech recognition. Falling back to recording mode.';
                    
                    // If recognition fails, fall back to mediaRecorder
                    usingSpeechRecognition = false;
                    startMediaRecorder();
                }
            } else {
                // Fall back to mediaRecorder
                startMediaRecorder();
            }
        }
        
        // Start media recorder (fallback method)
        async function startMediaRecorder() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                audioChunks = [];
                
                // Create media recorder
                mediaRecorder = new MediaRecorder(stream);
                
                // Set up data handler for audio chunks
                mediaRecorder.addEventListener('dataavailable', event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                });
                
                // Start recording with 5-second chunks for incremental processing
                mediaRecorder.start(3000);  // 3秒ごとに処理に変更
                
                // Process chunks periodically
                mediaRecorder.addEventListener('stop', processMediaRecorderChunks);
                mediaRecorder.addEventListener('dataavailable', () => {
                    // Process after each chunk if we have enough data
                    if (audioChunks.length > 0) {
                        processMediaRecorderChunks();
                    }
                });
                
                console.log('Media recorder started');
            } catch (error) {
                console.error('Error starting media recorder:', error);
                status.textContent = 'Microphone error - check permissions';
                status.classList.remove('idle', 'recording');
                status.classList.add('error');
                errorMessage.textContent = 'Failed to access microphone: ' + error.message;
                isRecording = false;
                document.body.classList.remove('recording');
                updateButtonVisibility(false);
            }
        }
        
        // Process media recorder chunks
        async function processMediaRecorderChunks() {
            if (audioChunks.length === 0 || !isRecording) return;
            
            try {
                // Create a blob from the accumulated chunks
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                
                // Only process if the blob is large enough
                if (audioBlob.size > 1000) {
                    // Show transcribing status
                    listeningIndicator.classList.add('visible');
                    
                    // Transcribe using Gladia API
                    const transcript = await transcribeAudio(audioBlob);
                    
                    // Hide transcribing status when done
                    listeningIndicator.classList.remove('visible');
                    
                    if (transcript && transcript.trim()) {
                        // Append to final transcript if new text
                        if (finalTranscript.length === 0) {
                            finalTranscript = transcript;
                        } else if (transcript.length > finalTranscript.length) {
                            // Try to avoid duplicating text by only appending new portions
                            const newPortion = transcript.substring(finalTranscript.length).trim();
                            if (newPortion) {
                                finalTranscript += ' ' + newPortion;
                            } else {
                                finalTranscript = transcript; // Just use the new transcript if we can't find new portions
                            }
                        }
                        
                        // Update UI
                        originalText.textContent = finalTranscript;
                        
                        // Override detected language with selected language in this mode
                        // since we explicitly know what language the user selected
                        if (selectedLanguage) {
                            if (selectedLanguage === 'ja') {
                                sourceLanguage.textContent = 'Japanese';
                                targetLanguage.textContent = 'English';
                            } else {
                                sourceLanguage.textContent = 'English';
                                targetLanguage.textContent = 'Japanese';
                            }
                        }
                        
                        // Translate if we have significant new content
                        if (finalTranscript.length > lastProcessedText.length + 5) {
                            translateText(finalTranscript);
                            lastProcessedText = finalTranscript;
                        }
                    }
                }
                
                // Keep recording if we're still in recording mode
                if (isRecording && mediaRecorder && mediaRecorder.state === 'inactive') {
                    // Clear chunks for next recording segment
                    audioChunks = [];
                    
                    try {
                        mediaRecorder.start(3000);  // 3秒ごとに処理に変更
                    } catch (e) {
                        console.error('Failed to restart media recorder', e);
                        errorMessage.textContent = 'Recording error: ' + e.message;
                    }
                }
            } catch (error) {
                console.error('Error processing media recorder chunks:', error);
                errorMessage.textContent = 'Error processing audio: ' + error.message;
            }
        }
        
        // Transcribe audio using Gladia API
        async function transcribeAudio(audioBlob) {
            try {
                // Upload audio file
                const uploadFormData = new FormData();
                uploadFormData.append('audio', audioBlob, 'recording.webm');
                
                console.log('Uploading audio to Gladia API...');
                const uploadResponse = await fetch('https://api.gladia.io/v2/upload/', {
                    method: 'POST',
                    headers: {
                        'x-gladia-key': GLADIA_API_KEY.trim()
                    },
                    body: uploadFormData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`Gladia Upload API error: ${uploadResponse.status}`);
                }
                
                const uploadResult = await uploadResponse.json();
                const audioUrl = uploadResult.audio_url;
                
                if (!audioUrl) {
                    throw new Error('Failed to get audio URL from Gladia');
                }
                
                // Request transcription with selected language hint if available
                const transcriptionPayload = {
                    audio_url: audioUrl,
                    detect_language: true,
                    diarization: false
                };
                
                // If we know the language, add it as a hint to improve accuracy
                if (selectedLanguage) {
                    transcriptionPayload.language = selectedLanguage === 'ja' ? 'ja' : 'en';
                }
                
                console.log('Sending transcription request to Gladia API...');
                const transcriptionResponse = await fetch('https://api.gladia.io/v2/transcription/', {
                    method: 'POST',
                    headers: {
                        'x-gladia-key': GLADIA_API_KEY.trim(),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(transcriptionPayload)
                });
                
                if (!transcriptionResponse.ok) {
                    throw new Error(`Gladia Transcription API error: ${transcriptionResponse.status}`);
                }
                
                const transcriptionRequestResult = await transcriptionResponse.json();
                const resultUrl = transcriptionRequestResult.result_url;
                
                if (!resultUrl) {
                    throw new Error('Failed to get result URL from Gladia');
                }
                
                // Poll for result
                console.log('Polling for transcription result...');
                let transcriptionResult;
                let maxRetries = 15;
                let retryDelay = 500;
                
                for (let i = 0; i < maxRetries; i++) {
                    const pollResponse = await fetch(resultUrl, {
                        method: 'GET',
                        headers: {
                            'x-gladia-key': GLADIA_API_KEY.trim()
                        }
                    });
                    
                    if (!pollResponse.ok) {
                        throw new Error(`Gladia Poll API error: ${pollResponse.status}`);
                    }
                    
                    const pollResult = await pollResponse.json();
                    
                    if (pollResult.status === 'done') {
                        transcriptionResult = pollResult.result;
                        break;
                    } else if (pollResult.status === 'error') {
                        throw new Error(`Gladia transcription error: ${pollResult.error}`);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                }
                
                if (!transcriptionResult) {
                    throw new Error('Transcription timed out');
                }
                
                // Extract transcript
                const utterances = transcriptionResult.transcription.utterances || [];
                const transcribedText = utterances.map(u => u.text).join(' ').trim();
                
                console.log('Transcription successful:', transcribedText);
                return transcribedText;
                
            } catch (error) {
                console.error('Transcription error:', error);
                errorMessage.textContent = 'Transcription error: ' + error.message;
                throw error;
            }
        }
        
        // Stop recording
        function stopRecording() {
            isRecording = false;
            document.body.classList.remove('recording');
            status.textContent = 'Processing';
            status.classList.remove('recording');
            status.classList.add('processing');
            
            // Update button visibility - show start buttons, hide stop button
            updateButtonVisibility(false);
            
            if (usingSpeechRecognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error('Error stopping recognition', e);
                }
                
                // Final translation of any remaining text
                if (finalTranscript && finalTranscript !== lastProcessedText) {
                    translateText(finalTranscript);
                }
                
                // Update status after processing
                setTimeout(() => {
                    status.textContent = 'Ready';
                    status.classList.remove('processing');
                    status.classList.add('idle');
                }, 1000);
            } else if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                
                // Stop all tracks on the stream
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                // Process any remaining audio (will be handled by the stop event listener)
                // Then update status after a delay
                setTimeout(() => {
                    status.textContent = 'Ready';
                    status.classList.remove('processing');
                    status.classList.add('idle');
                }, 3000);
            }
            
            console.log('Recording stopped');
        }
        
        // Last translation timestamp
        let lastTranslationTime = 0;
        
        // Translate text using OpenAI streaming API
        async function translateText(text) {
            if (!text || !text.trim() || translationInProgress) return;
            
            translationInProgress = true;
            lastTranslationTime = Date.now();
            translatingIndicator.classList.add('visible');
            
            // Clear any previous error messages
            errorMessage.textContent = '';
            
            try {
                // Determine source language based on the selected language button
                // rather than trying to auto-detect from the text
                const sourceLanguageStr = selectedLanguage === 'ja' ? 'Japanese' : 'English';
                
                // Abort previous translation if in progress
                if (currentTranslationController) {
                    currentTranslationController.abort();
                }
                
                // Create new abort controller
                currentTranslationController = new AbortController();
                const signal = currentTranslationController.signal;
                
                // Create OpenAI request
                const translationPayload = {
                    model: 'o3-mini',
                    messages: [
                        {
                            role: 'system',
                            content: window.SYSTEM_PROMPT
                        },
                        {
                            role: 'user',
                            content: `Translate this ${sourceLanguageStr} text:\n\n${text}`
                        }
                    ],
                    stream: true  // Enable streaming for real-time response
                };
                
                // Properly format API key (ensure it's trimmed)
                const apiKey = OPENAI_API_KEY.trim();
                console.log('API Key prefix:', apiKey.substring(0, 7) + '...');
                
                console.log('Sending translation request to OpenAI API...');
                
                // Request translation with properly formatted Authorization header
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey  // No template string to avoid any whitespace issues
                    },
                    body: JSON.stringify(translationPayload),
                    signal: signal
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API error response:', errorText);
                    let errorObj = {};
                    try {
                        errorObj = JSON.parse(errorText);
                    } catch (e) {
                        // テキストをそのまま使用
                    }
                    
                    const errorDetails = errorObj.error ? 
                        `${errorObj.error.message || errorObj.error.type || "Unknown error"}` : 
                        `Status: ${response.status}`;
                        
                    throw new Error(`OpenAI API error: ${errorDetails}`);
                }
                
                console.log('Translation stream started');
                
                // Process the streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let translationResult = '';
                
                // Clear previous translation
                translatedText.textContent = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    // Decode the chunk
                    const chunk = decoder.decode(value);
                    
                    // Process each line from the chunk
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            try {
                                const data = JSON.parse(line.substring(6));
                                if (data.choices && data.choices[0].delta && data.choices[0].delta.content) {
                                    const content = data.choices[0].delta.content;
                                    translationResult += content;
                                    translatedText.textContent = translationResult;
                                }
                            } catch (e) {
                                console.error('Error parsing streaming response:', e);
                            }
                        }
                    }
                }
                
                console.log('Translation completed successfully');
                
                // Ensure the current controller is reset
                currentTranslationController = null;
                
            } catch (error) {
                // Ignore abort errors
                if (error.name === 'AbortError') {
                    console.log('Translation request aborted');
                } else {
                    console.error('Translation error:', error);
                    errorMessage.textContent = error.message;
                    if (translatedText.textContent === '') {
                        translatedText.textContent = '(Translation error - please try again)';
                    }
                }
            } finally {
                translationInProgress = false;
                translatingIndicator.classList.remove('visible');
            }
        }
        
        // Function to detect if text is likely Japanese (for fallback only)
        function isJapaneseText(text) {
            // Japanese characters unicode ranges
            const japaneseRegex = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf]/;
            return japaneseRegex.test(text);
        }
        
        // Initialize the app
        loadApiKeys();
    });
    </script>
</body>
</html>